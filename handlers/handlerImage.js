// handlerImage.js
import { sendMessageWait } from "../reply/text_reply.js";
import { sendMessageSame } from "../reply/same_reply.js";
import { getRandomReplyFromFile } from "./textBot/textUtils/reply.js";
import { loadQRDatabaseFromFile, saveQRDatabaseToFile } from "../utils/qrData.js";
import { addToUserQueue, finishUserTask } from "../utils/userQueueManager.js";
import { analyzeSlipImage, streamToBuffer } from "../utils/qrSlipworker.js";
import { handleRegularSlip } from "./Image/regularSlipChecker.js";
import { getLineProfile } from "../utils/getLineProfile.js";
import { reportSlipResultToAPI } from "../utils/slipStatsManager.js";
import { setUserSentSlip, setUserSentImage, clearUserMessageHistory, clearUserTimeout } from "./handleEvent.js";
import { isNewCustomer } from "../utils/savePhoneNumber.js";
import { broadcastLog } from "../index.js";
import { getCachedSettings, reloadSettings } from "../utils/settingsManager.js";
import { connectDB } from "../mongo.js";
import Shop from "../models/Shop.js";

/**
 * ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡∏ã‡πâ‡∏≥
 * @param {string} qrData - ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• QR ‡∏ó‡∏µ‡πà‡∏™‡πÅ‡∏Å‡∏ô‡πÑ‡∏î‡πâ
 * @param {string} userId - ‡∏£‡∏´‡∏±‡∏™‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ
 * @param {Map} qrDatabase - ‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• QR Code
 * @param {object} client - LINE client ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡πà‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö
 * @param {string} replyToken - reply token ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö LINE
 * @param {string} prefix - ‡∏£‡∏´‡∏±‡∏™‡∏£‡πâ‡∏≤‡∏ô (‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•)
 */

let shopData = [];

export async function loadShopDataFromDB() {
  try {
    await connectDB(); // ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏° MongoDB ‡∏ñ‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°
    shopData = await Shop.find({}); // ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
  } catch (err) {
    console.error("‚ùå ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡πâ‡∏≤‡∏ô‡∏à‡∏≤‡∏Å MongoDB ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à:", err.message);
    shopData = [];
  }
}

// ‚úÖ ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏£‡πâ‡∏≤‡∏ô‡πÅ‡∏•‡∏∞ settings ‡∏ï‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°
(async () => {
  await loadShopDataFromDB();
  await reloadSettings();
})();

const programStartTime = Date.now(); // ‡πÄ‡∏ß‡∏•‡∏≤‡∏ó‡∏µ‡πà‡πÇ‡∏õ‡∏£‡πÅ‡∏Å‡∏£‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
const userMessageCount = new Map(); // ‡πÄ‡∏Å‡πá‡∏ö‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏™‡∏•‡∏¥‡∏õ‡∏ó‡∏µ‡πà‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏™‡πà‡∏á

async function loadShopAndQRData(prefix) {
  const shop = shopData.find((s) => s.prefix === prefix);
  if (!shop) {
    console.log(`‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡πâ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ prefix: ${prefix}`);
    broadcastLog(`‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡πâ‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏°‡∏µ prefix: ${prefix}`);
    return {};
  }
  const qrDatabase = (await loadQRDatabaseFromFile(prefix)) || new Map();
  return { shop, qrDatabase };
}


async function processSuspiciousSlip({ linename, lineName, image }) {
  console.log("‚ö†Ô∏è ‡∏û‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏á‡∏™‡∏±‡∏¢ ( ‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡∏™‡∏•‡∏¥‡∏õ ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ QRcode ‡∏´‡∏£‡∏∑‡∏≠ ‡∏õ‡∏•‡∏≠‡∏°‡∏™‡∏•‡∏¥‡∏õ )");
  broadcastLog("‚ö†Ô∏è ‡∏û‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏á‡∏™‡∏±‡∏¢ ( ‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡∏™‡∏•‡∏¥‡∏õ ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ QRcode ‡∏´‡∏£‡∏∑‡∏≠ ‡∏õ‡∏•‡∏≠‡∏°‡∏™‡∏•‡∏¥‡∏õ )");
  await reportSlipResultToAPI({
    time: getCurrentTimeOnly(),
    shop: linename,
    lineName,
    image,
    status: "‡∏û‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡∏ï‡πâ‡∏≠‡∏á‡∏™‡∏á‡∏™‡∏±‡∏¢ ( ‡∏≠‡∏≤‡∏à‡πÄ‡∏õ‡πá‡∏ô‡∏†‡∏≤‡∏û‡∏™‡∏•‡∏¥‡∏õ ‡πÅ‡∏ï‡πà‡πÑ‡∏°‡πà‡∏°‡∏µ QRcode ‡∏´‡∏£‡∏∑‡∏≠ ‡∏õ‡∏•‡∏≠‡∏°‡∏™‡∏•‡∏¥‡∏õ )",
    response: "‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö",
  });
}

async function processDuplicateSlip({
  event,
  client,
  qrData,
  qrDatabase,
  userId,
  now,
  sameQrTimeLimit,
  maxMessagesSamePerUser,
  linename,
  lineName,
  image,
  prefix,
}) {
  console.log(`üì¶ QR ‡∏ô‡∏µ‡πâ‡πÄ‡∏Ñ‡∏¢‡∏ñ‡∏π‡∏Å‡∏ï‡∏£‡∏ß‡∏à‡πÅ‡∏•‡πâ‡∏ß`);
  const qrInfo = qrDatabase.get(qrData);
  const qrUsers = Array.from(qrInfo.users.keys());
  console.log(`üìå ‡∏û‡∏ö‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡∏ó‡∏µ‡πà‡πÄ‡∏Ñ‡∏¢‡∏™‡πà‡∏á QR ‡∏ô‡∏µ‡πâ: ${qrUsers.join(", ")}`);

  if (qrInfo.users.has(userId)) {
    const userRecord = qrInfo.users.get(userId);
    const lastSentTime = userRecord.lastSentTime || 0;
    const sameMessageCount = userRecord.messageCount || 0;
    console.log(`üîÑ [‡∏ã‡πâ‡∏≥] ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏î‡∏¥‡∏°‡πÄ‡∏Ñ‡∏¢‡∏™‡πà‡∏á QR ‡∏ô‡∏µ‡πâ`);
    console.log(
      `‚è±Ô∏è ‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏î‡∏¥‡∏°: ${new Date(lastSentTime).toLocaleString("th-TH", { timeZone: "Asia/Bangkok" })}`
    );
    console.log(`üìä messageCount = ${sameMessageCount}`);

    if (now - lastSentTime < sameQrTimeLimit) {
      if (sameMessageCount < maxMessagesSamePerUser) {
        console.log(`üîî ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö "‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà" ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö ${userId}`);
        broadcastLog(`üîî ‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö "‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà" ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÅ‡∏£‡∏Å‡πÉ‡∏´‡πâ‡∏Å‡∏±‡∏ö ${userId}`);
        await reportSlipResultToAPI({
          time: getCurrentTimeOnly(),
          shop: linename,
          lineName,
          image,
          status: "‡∏™‡∏•‡∏¥‡∏õ‡∏ã‡πâ‡∏≥ ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 1 ‡∏ä‡∏±‡πà‡∏ß‡πÇ‡∏°‡∏á",
          response: "‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö '‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà'",
          amount: qrInfo.amount,
          ref: qrData,
        });
        await sendMessageWait(event.replyToken, client);

        qrInfo.users.set(userId, {
          lastSentTime: now,
          messageCount: sameMessageCount + 1,
        });

        saveQRDatabaseToFile(prefix, qrDatabase);
        finishUserTask(userId);
        return true;
      } else {
        console.log(
          `‚è≥ ‡πÄ‡∏û‡∏¥‡∏Å‡πÄ‡∏â‡∏¢: ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ${userId} ‡∏™‡πà‡∏á‡∏ã‡πâ‡∏≥‡πÄ‡∏Å‡∏¥‡∏ô ${maxMessagesSamePerUser} ‡∏Ñ‡∏£‡∏±‡πâ‡∏á`
        );
        broadcastLog(
          `‚è≥ ‡πÄ‡∏û‡∏¥‡∏Å‡πÄ‡∏â‡∏¢: ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ${userId} ‡∏™‡πà‡∏á‡∏ã‡πâ‡∏≥‡πÄ‡∏Å‡∏¥‡∏ô ${maxMessagesSamePerUser} ‡∏Ñ‡∏£‡∏±‡πâ‡∏á`
        );
        return true;
      }
    }
  }

  const tranRef = qrData.length > 20 ? qrData.slice(-20) : qrData;
  console.log(`üî¥ ‡∏û‡∏ö‡∏™‡∏•‡∏¥‡∏õ QR Code ‡∏ã‡πâ‡∏≥ ‚ùå`);
  broadcastLog(`üî¥ ‡∏û‡∏ö‡∏™‡∏•‡∏¥‡∏õ QR Code ‡∏ã‡πâ‡∏≥ ‚ùå`);
  saveQRDatabaseToFile(prefix, qrDatabase);
  finishUserTask(userId);

  await reportSlipResultToAPI({
    time: getCurrentTimeOnly(),
    shop: linename,
    lineName,
    image,
    status: "‡∏™‡∏•‡∏¥‡∏õ‡∏ã‡πâ‡∏≥‡πÄ‡∏î‡∏¥‡∏°",
    response: "‡∏ï‡∏≠‡∏ö‡∏Å‡∏•‡∏±‡∏ö‡πÅ‡∏•‡πâ‡∏ß",
    amount: qrInfo.amount,
    ref: qrData,
  });

  await sendMessageSame(
    event.replyToken,
    client,
    new Date(qrInfo.firstDetected).toLocaleString("th-TH", {
      timeZone: "Asia/Bangkok",
    }) + " ‡∏ô.",
    tranRef
  );
  return true;
}

async function forwardNormalSlip({
  event,
  client,
  qrData,
  qrDatabase,
  userId,
  now,
  timeLimit,
  maxMessagesPerUser,
  prefix,
  shop,
  linename,
  lineName,
  image,
  userInfo,
}) {
  if (
    now - userInfo.lastSentTime < timeLimit &&
    userInfo.qrMessageCount >= maxMessagesPerUser
  ) {
    console.log(
      `‚è≥ ‡πÄ‡∏û‡∏¥‡∏Å‡πÄ‡∏â‡∏¢: ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ${userId} ‡∏™‡πà‡∏á‡∏™‡∏•‡∏¥‡∏õ‡πÄ‡∏Å‡∏¥‡∏ô ${maxMessagesPerUser} ‡∏Ñ‡∏£‡∏±‡πâ‡∏á`
    );
    broadcastLog(
      `‚è≥ ‡πÄ‡∏û‡∏¥‡∏Å‡πÄ‡∏â‡∏¢: ‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ ${userId} ‡∏™‡πà‡∏á‡∏™‡∏•‡∏¥‡∏õ‡πÄ‡∏Å‡∏¥‡∏ô ${maxMessagesPerUser} ‡∏Ñ‡∏£‡∏±‡πâ‡∏á`
    );
    return;
  }

  userMessageCount.set(userId, {
    lastSentTime: now,
    qrMessageCount: userInfo.qrMessageCount + 1,
  });

  const tranRef = qrData.length > 20 ? qrData.slice(-20) : qrData;
  const qrEntry = {
    firstDetected: now,
    users: new Map([[userId, { lastSentTime: now, messageCount: 1 }]]),
  };

  if (shop.slipCheckOption === "all") {
    console.log(`üÜï ‡∏™‡πà‡∏á‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏•‡∏¥‡∏õ‡∏ó‡∏µ‡πà SlipOK`);
    broadcastLog(`üÜï ‡∏™‡πà‡∏á‡∏ï‡πà‡∏≠‡πÑ‡∏õ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏•‡∏¥‡∏õ‡∏ó‡∏µ‡πà SlipOK`);
    const slipData = await handleRegularSlip(
      client,
      event.message.id,
      event.replyToken,
      prefix,
      qrDatabase,
      qrData,
      userId,
      lineName,
      image,
      linename,
      tranRef
    );
    if (slipData && slipData.amount !== undefined) {
      qrEntry.amount = slipData.amount;
    }
  }

  qrDatabase.set(qrData, qrEntry);
  saveQRDatabaseToFile(prefix, qrDatabase);
  finishUserTask(userId);
}


export async function handleImageEvent(event, client, prefix, linename, qrDatabase) {
  try {
    const {
      timeLimit,
      sameQrTimeLimit,
      maxMessagesPerUser,
      maxMessagesSamePerUser,
    } = getCachedSettings();
    
    const userId = event.source.userId;
    const messageId = event.message.id;
    const now = Date.now();
    clearUserTimeout(userId);
    clearUserMessageHistory(userId);

    const { shop, qrDatabase: loadedQRDatabase } = await loadShopAndQRData(prefix);
    if (!shop) return;
    qrDatabase = loadedQRDatabase;

    addToUserQueue(userId, async () => {
      const stream = await client.getMessageContent(messageId);
      const buffer = await streamToBuffer(stream);
      const qrData = await analyzeSlipImage(buffer);
      const profile = await getLineProfile(userId, shop.lines[0].access_token);
      const lineName = profile?.displayName || "-";
      const image = profile?.pictureUrl || "";
      const isNew = isNewCustomer(userId);

      if (event.timestamp < programStartTime) return;

      if (!qrData) {
        console.log("‚ùå ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏†‡∏≤‡∏û‡∏™‡∏•‡∏¥‡∏õ");
        broadcastLog("‚ùå ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏†‡∏≤‡∏û‡∏™‡∏•‡∏¥‡∏õ");
        setUserSentImage(userId);
        console.log("‡∏†‡∏≤‡∏û‡∏ó‡∏±‡πà‡∏ß‡πÑ‡∏õ ‚Üí ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ß‡πà‡∏≤ user ‡∏™‡πà‡∏á‡∏£‡∏π‡∏õ‡∏°‡∏≤");
        return;
      }

      setUserSentSlip(userId);
      console.log("‡∏ï‡∏£‡∏ß‡∏à‡∏û QR ‚Üí ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ß‡πà‡∏≤ user ‡∏™‡πà‡∏á‡∏™‡∏•‡∏¥‡∏õ");


      if (qrData.suspicious) {
        await processSuspiciousSlip({ linename, lineName, image });
        return;
      }

      console.log("üì• QR Code ‡∏ó‡∏µ‡πà‡∏™‡πÅ‡∏Å‡∏ô‡πÑ‡∏î‡πâ:", qrData);
      broadcastLog(`üì• QR Code ‡∏ó‡∏µ‡πà‡∏™‡πÅ‡∏Å‡∏ô‡πÑ‡∏î‡πâ: ${qrData}`);

      if (!userMessageCount.has(userId)) {
        userMessageCount.set(userId, { lastSentTime: 0, qrMessageCount: 0 });
      }
      const userInfo = userMessageCount.get(userId);

      if (qrDatabase.has(qrData)) {
        const handled = await processDuplicateSlip({
          event,
          client,
          qrData,
          qrDatabase,
          userId,
          now,
          sameQrTimeLimit,
          maxMessagesSamePerUser,
          linename,
          lineName,
          image,
          prefix,
        });
        if (handled) return;
      }

      await forwardNormalSlip({
        event,
        client,
        qrData,
        qrDatabase,
        userId,
        now,
        timeLimit,
        maxMessagesPerUser,
        prefix,
        shop,
        linename,
        lineName,
        image,
        userInfo,
      });
    });
  } catch (error) {
    console.error(`‚ùå Error processing event for PREFIX ${prefix}: ${error.message}`);
    broadcastLog(`‚ùå Error processing event for PREFIX ${prefix}: ${error.message}`);
  }
}

function getCurrentTimeOnly() {
  return new Date().toLocaleTimeString("th-TH", {
    hour: "2-digit",
    minute: "2-digit",
    timeZone: "Asia/Bangkok"
  }) + " ‡∏ô.";
}

